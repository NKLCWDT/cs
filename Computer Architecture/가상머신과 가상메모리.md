## 가상머신(Virtual Machine)
하나의 하드웨어(CPU, Memory등)에 다수의 운영체제를 설치하고, 개별 컴퓨터 처럼 동작하도록 하는 프로그램  
하드웨어를 소프트웨어로 에뮬레이터하여(모사) 마치 여러개 처럼 보이도록 하는 기술

<img width="690" alt="image" src="https://user-images.githubusercontent.com/70622731/156925789-88554cdb-d347-49f1-a356-670855f07ff1.png">

### 가상머신을 사용하는 이유
- 다른 운영체제를 사용해야 하는 경우 (맥OS에서 윈도우, 윈도우에서 리눅스)
- 독립된 작업공간이 필요한 경우 (바이러스 회피, 백업)

### 가상머신 Type1 (하이퍼바이저 가상화)
하드웨어 위에 VMM을 설치  
하이퍼바이저(VMM) : 가상머신을 생성하고 구동하는 소프트웨어이다.  
하이퍼바이저 또는 버추얼 머신 모니터(VMM)라고 하는 소프트웨어가 Hardware에서 직접 구동

- 장점 : 별도의 Host OS가 없기 때문에 오버헤드가 적고, 하드웨어를 직접 제어하기 때문에 효율적으로 리소스를 사용할 수 있음
- 단점 : 자체적으로 머신에 대한 관리 기능이 없기 때문에 관리를 위한 컴퓨터나 콘솔이 필요함

예) Oracle VM Server for X86, VM Server, Citrix Xenserver, Hyper-V 등

![image](https://user-images.githubusercontent.com/70622731/156925802-7989b1a3-ad34-4922-b651-8f03afd70c58.png)

### 가상머신 Type1 두가지 종류

- 전가상화(Full Virtualization)
    각 가상머신이 하이퍼바이저를 통해서 하드웨어와 통신  
    하이퍼바이저가 마치 하드웨어인 것처럼 동작하므로, 가상머신의 OS는 자신이 가상 머신인 상태인지를 모른다.  
    가상 머신에 설치된 운영체제들은 하드웨어에 뭔가 요청을 할 때 하이퍼바이저가 OS 요청을 받아 하드웨어 전달한다.  

  - 장점 : 하드웨어를 완전히 가상화하기 때문에 Guest OS 운영체제의 별다른 수정이 필요 없음  
  - 단점 : 하이퍼바이저가 모든 명령을 중재하기 때문에 성능이 비교적 느림

![image](https://user-images.githubusercontent.com/70622731/156925816-b1ce8702-a67e-4c84-b2cf-c834778374f2.png)

- 반가상화(Half Virtualization)
    각 가상머신에서 직접 하드웨어와 통신  
    각 가상머신에 설치되는 OS는 가상머신인 경우, 이를 인지하고, 각 명령에 하이퍼바이저 명령을 추가해서 하드웨어 통신한다.  
    가상머신에 설치된 OS가 하드웨어에 직접적으로 명령한다.  
    반가상화에서 하이퍼바이저의 역할 : 리소스 관리, 가상머신마다 하드웨어에 요청했을 때의 자원을 관리한다.
    - 장점 : 모든 명령을 DOM0를 통해 하이퍼바이저에게 요청하는 전가상화에비해 성능이 빠름 
    - 단점 : 하이퍼바이저에게 Hyper Call 요청을 할 수 있도록 각 OS의 커널을 수정해야하며 오픈소스 OS가 아니면 반가상화를 이용하기가 쉽지 않음

![image](https://user-images.githubusercontent.com/70622731/156925826-daf7b22d-bf4b-41aa-99f0-abf5d4df0937.png)


### 가상머신 Type2 (호스트 가상화)
하드웨어 위에 운영체제가 이미 설치되어 있는 경우
하이퍼바이저를 Host OS 상위에 설치

- 장점 : 가상의 하드웨어를 에뮬레이팅하기 때문에 호스트 운영체제에 크게 제약사항이 없음
- 단점 : OS위에 OS가 얹히는 방식이기 때문에 오버헤드가 클 수 있음

예) Vmare Workstation, Virtual Server 2005, Virtual Box 등

![image](https://user-images.githubusercontent.com/70622731/156925846-4e68c223-9b2d-4e07-9bb7-f0ba406fff93.png)


<br>

## 가상메모리
가상메모리란 메모리를 관리하는 방법으로 실제 메모리 주소가 아닌 논리적 주소를 이용해서 관리한다.  
실제로 프로그램 수행에 필요한 부분만 메모리에 올려놓음으로써 주기억장치의 용량보다 큰 프로그램이라도 메모리에 올려놓을 수 있게하는 기법이다.

![image](https://user-images.githubusercontent.com/70622731/156925861-0c7db543-5b7b-436e-a218-52636389fcab.png)

### 가상메모리 이점
- 실제메모리(RAM) 크기 보다 더 큰 공간을 사용할 수 있다. (보조 기억장치 공간 사용)
- 가상의 주소 공간을 사용하여 논리적인 연속성을 제공해준다.
- 물리메모리 주소 공간을 알 필요가 없어진다.

### 가상메모리 원리
항상 모든 프로그램에 대한 데이터가 필요한 것이 아니기 때문에 프로그램의 일부분을 필요한만큼 계속 RAM에만 올려놓도록 하고 나머지는 backing storage에 넣어놓고 필요할 때 가져다 쓴다. => 캐시의 원리와 같다.

대표적으로 [세그멘테이션과 페이징](https://github.com/NKLCWDT/cs/blob/main/Operating%20System/%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98%EA%B3%BC%20%ED%8E%98%EC%9D%B4%EC%A7%95.md) 이 있다.

### 요구페이징
지금의 가상메모리 기법을 존재하게 한 것  
대부분의 프로그램이 프로그램 전체가 적재되지 않아도 사용가능하다는 특징을 이용해서, 필요한 페이지만 저장공간에 적재하고, 다른 페이지는 보조기억장치에 적재해서 사용한다.

![image](https://user-images.githubusercontent.com/70622731/156925880-0821d879-b490-4c5b-83c8-31627eceebe2.png)

- 논리적 메모리 : 프로그램들이 보는 메모리, 순서대로 주소가 부여됨
- 물리적 메모리 : 실제로 존재하는 메모리
- 페이지 테이블 : 페이징 기법에서 사용되는 자료구조

> 타당(valid) : 물리적 메모리에 존재한다.  
> 비타당(invalid) : 물리적 메모리에 존재하지 않는다.

페이징에 자세한 설명은 세그멘테이션과 페이징 링크에 자세히 설명되어 있다.

<br>

---

### Reference

https://probe29.tistory.com/28?category=1168027

https://luv-n-interest.tistory.com/1005

https://velog.io/@gimtommang11/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC

https://tech.cloud.nongshim.co.kr/2018/09/18/%EA%B0%80%EC%83%81%ED%99%94%EC%9D%98-%EC%A2%85%EB%A5%983%EA%B0%80%EC%A7%80/
